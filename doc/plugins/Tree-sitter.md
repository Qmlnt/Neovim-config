[GitHub link](https://github.com/nvim-treesitter/nvim-treesitter)
_An incremental parsing system for programming tools. Provides syntax highlighting and code actions._

Nvim-treesitter is based on three interlocking features: **language parsers**, **queries**, and **modules**, where `modules` provide features – e.g., highlighting – based on `queries` for syntax objects extracted from a given buffer by `language parsers`.

For `nvim-treesitter` to support a specific feature for a specific language requires both a **parser** for that language and an appropriate language-specific **query file** for that feature. _There may be no queries or queries at least for the `highlight` module_.

### Commands
- `:TSUpdate` – update all parsers to the latest version, **make sure to call this when upgrading the plugin**.
- `:TSInstall <language_to_install>`, _supports tab expansion_.
- `:TSInstallInfo` – list all available languages and their installation status.
- `:TSModuleInfo` – list modules state. (_highlight, incremental\_selection, indent_).
- `TS(Buf)Enable`/`TS(Buf)Disable` – enable/disable module (in buffer), can take a filetype additionally.
- `:TSConfigInfo` – get a config table.
- `:checkhealth nvim-treesitter` has info about parser features.
- `:echo &ft` – prints filetype name.
- `:set ft=langname` – temporarily set the filetype for a single buffer.
- `:write | edit | TSBufEnable highlight` – fixes highlighting issues by reparsing the buffer which got out of sync with the current tree.
- `:Inspect` – check what treesitter parsed at the current cursor position.
- `:InspectTree` – view the whole syntax tree generated by treesitter.

### Configuration
Each module provides a distinct tree-sitter-based feature such as **highlighting**, **indentation**, or **folding**. _All modules are disabled by default and need to be activated explicitly in your configuration_.
- There are `highlight`, `indent` and `incremental_selection` – to enable set to `{ enable = true }`.
	- `highlight.disable` can take a `function(lang, buf)` which can return `true` to disable highlighting.
	- `indent` provides indentation based on treesitter for the `=` operator.
	- `incremental_selection.keymaps.<mapping>` – set to `false` to disable the `<mapping>`.
	- Also there is Folding, _which is per window and not per buffer_.
	  ```VimScript
		set foldmethod=expr
		set foldexpr=nvim_treesitter#foldexpr()
		set nofoldenable " Disable folding at startup.
	  ```
- `auto_install` = `true` – install missing parsers when **entering** a buffer. With [[Lazy]]'s `event = "VeryLazy"`, upon entering Neovim with `nvim file`, use `:e` to reload the buffer for auto installation to start. Also `tree-sitter-cli` needs to be installed locally.
- `ignore_install` = `{'p1','p2',..}` – do not (auto)install.
- `sync_install` = `false` – install parsers asynchronously (only for `ensure_installed`).

Using an existing parser for another filetype:
To use the `bash` tree-sitter to highlight file with `filetype=apkbuild`, use:
```lua
vim.treesitter.language.register("bash", "apkbuild")
```

### Textobjects
_A nvim-treesitter module which provides syntax aware text-objects: **select**, **move**, **swap**, and **peek**._
- `select` – select objects when doing `d`, `c`, `y`, or even `v`. For [[Which-key]] to display descriptions, `desc` can be used when defining keymaps.
	- `lookaround = true` will find and select an object even if it is not under the cursor.
	- `lookbehind` is also available, though it clashes with `lookaround`.
	- `include_surrounding_whitespace = true` to also select a space. Succeeding space has priority. _In Python `true` messes up the function body deletion by putting next function inside instead of a space_...
- `swap` – swap the node under the cursor with the next or previous one.
- `move` – jump to the next or previous object.
	- `set_jumps = true`set jumps in the jumplist. `C-o` – back, `C-i` (which is `Tab`) – forward.

You can make the movements repeatable like `;` and `,`.
```lua
local ts_repeat_move = require "nvim-treesitter.textobjects.repeatable_move"

-- Repeat movement with ; and ,
-- ensure ; goes forward and , goes backward regardless of the last direction
vim.keymap.set({ "n", "x", "o" }, ";", ts_repeat_move.repeat_last_move_next)
vim.keymap.set({ "n", "x", "o" }, ",", ts_repeat_move.repeat_last_move_previous)

-- vim way: ; goes to the direction you were moving.
-- vim.keymap.set({ "n", "x", "o" }, ";", ts_repeat_move.repeat_last_move)
-- vim.keymap.set({ "n", "x", "o" }, ",", ts_repeat_move.repeat_last_move_opposite)

-- Optionally, make builtin f, F, t, T also repeatable with ; and ,
vim.keymap.set({ "n", "x", "o" }, "f", ts_repeat_move.builtin_f)
vim.keymap.set({ "n", "x", "o" }, "F", ts_repeat_move.builtin_F)
vim.keymap.set({ "n", "x", "o" }, "t", ts_repeat_move.builtin_t)
vim.keymap.set({ "n", "x", "o" }, "T", ts_repeat_move.builtin_T)
```

Furthermore, you can make any custom movements (e.g. from another plugin) repeatable with the same keys. _This doesn't need to be treesitter-related_.
```lua
-- example: make gitsigns.nvim movement repeatable with ; and , keys.
local gs = require("gitsigns")

-- make sure forward function comes first
local next_hunk_repeat, prev_hunk_repeat = ts_repeat_move.make_repeatable_move_pair(gs.next_hunk, gs.prev_hunk)
-- Or, use `make_repeatable_move` or `set_last_move` functions for more control. See the code for instructions.

vim.keymap.set({ "n", "x", "o" }, "]h", next_hunk_repeat)
vim.keymap.set({ "n", "x", "o" }, "[h", prev_hunk_repeat)
```